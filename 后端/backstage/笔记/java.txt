window--CMD 
1、启动win+R，输入cmd回车
2、键盘名称: ,切换键盘
3、进入文件夹 cd 文件夹\文件夹2\文件夹3\
4、返回上一级,cd ..
5、直接返回跟路径,cd \
6、查看当前内容,dir
7、清屏，cls = `clear screen`
8、退出，exit


二、JVM虚拟机
1、java代码可以通过JVM运行到mac、window、Linux等平台， 通过虚拟机来翻译
2、JVM的虚拟机本身不具备跨平台功能，每个操作系统都有不同版本的虚拟机

三、JRE
1、java程序运行时环境，
2、包括JVM和运行时所需核心库

四、JDK
1、java程序开发工具包
2、包含JRE和开发人员使用的工具


总结：
1、我们需要运行一个已有的java程序只需要安JRE即可
2、我们需要开发一个全新的java程序那么必须安装JDK


mac 安装JDK
1、oracle.com 官网下载MAC JDK
2、将安装的路径放在 /Library/Java/JavaVirtualMachines/
3、打开 bash_profile 文件夹复制下边
3.0、open -e .bash_profile，打开
3.1、编辑bash_profile
3.2、注意jdk版本问题,黏贴如下
JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk-11.0.7.jdk/Contents/Home
PATH=$JAVA_HOME/bin:$PATH:.
CLASSPATH=$JAVA_HOME/lib/tools.jar:$JAVA_HOME/lib/dt.jar:.
export JAVA_HOME
export PATH
export CLASSPATH
4、配置文件生效
source .bash_profile
5、查看java版本号
java --version
6、测试开发
打开终端，在命令提示符后面直接输入javac,按回车键，系统会输入javac的帮助信息，如果成功说明已经成功配置JDK，否则需要检查上面的步骤是否正确


1、记事本写java,
2、编译,javac helloWorld.java
3、运行，java helloWorld

标识符
是在程序中我们自定义的内容，比如类的名字和方法的名字和变量的名字等等都是标志符
HelloWorld案例中，出现的标识符有类名字HelloWorld

命名规则
1、标识符可以包含，英文字母26个区分大小写，0-9数字，$(美元符号),和下换线
2、标识符不能以数字开头
3、标识符不能是关键字

命名规范
1、类名规范，首字母大写，后面每个单词首字母大写，驼峰命名
2、变量名规范，首字母小写，后面每个单词首字母大写，小驼峰命名
3、方法名规范，同变量名



常量，程序运行期间，固定不变的量。
常量的分类:
1、字符串常量，凡是用“”引起来的部分，叫做字符串常量。例如:"abc"
2、整数常量
3、浮点数常量，有小数点，例如，2.5,-3.14
4、字符常量，凡是用''引起来的，叫做字符常量例如：'A'
5、布尔常量，只有量中取值，true,false
6、空常量,null,代表没有任何数据

变量，程序运行期间，内容可以发生改变的量
创建一个变量
数据类型 变量名称;// 创建一个变量
变量名称 = 数据值；// 赋值

使用Int类型的注意事项
1、如果创建多个变量，那么变量之间的名称不可以重复
2、对于float和long类型来说，字母后缀F和L不要丢掉
3、如果使用byte和short类型变量，右侧的值不能超过左侧的类型范围
4、没有进行变量赋值的变量不能直接使用,一定赋值之后才能使用
5、变量的使用不能超出作用域的范围
6、通过一个语句创建多个变量，一般情况下不推荐使用 ，Int a = 100,b = 200,c = 300;同时创建了3个Int类型的变量a,b,c


当数据类型不一样的时候，会发生数据类型转换
自动类型转换(隐式)
1、特点，代码不需要进行特殊处理，自动完成
2、规则，数据范围从小到大
强制类型转换
1、特点，代码需要进行特殊的格式处理，不能自动完成。
2、格式，范围小的类型，范围小的变量名 = (范围小的的类型)范围大的数据

注意事项：
1、强制类型转换一般推荐使用，因为有可能发生精度损失，数据溢出
2、byte,short,char都可以发生数学运算，例如加法'+'
3、byte,short,char在运算的时候，都会被首先提升为Int类型然后在计算， 
4、boolean类型不能发生类型转换


数据类型 变量名称 = 数据值；// 创建变量的同时立即放入指定的数据值

注意事项：
1、单引号 有且仅有一个字符，没有报错
2、空常量，不能直接用来打印输出

基本数据类型
1、整数型 byte short int long
2、浮点型 float double
3、字符型 char
4、布尔型 boolean

引用数据类型
字符串、数组、类、接口、Lambda

注意
1、字符串不是基本类型，而是引用类型
2、浮点型可能只是一个近似值，并非精确值
3、数据范围与字节数不一定相关，例如float数据范围比long更加广泛
但是float是4字节，但是long是8字节
4、浮点数默认数据类型是double 如果一定使用float类型，需要加一个后缀F。
5、如果是整数，默认是Int类型， 如果一定使用long类型，需要加上一个后缀L,推荐使用大写后缀。



数字和字符的对照关系表(编码表)
ASCII码表：American Standard Code For Information Interchange 美国信息交换标准码
Unicode码表：万国码也是数字和字符的对照关系，开头0-127和ASCII码一样，但是从128开始包含更多字符
Emoji
48 - '0'
65 - 'A'
97 - 'a'

运算符
+
-
*
/ 
% - 取模运算符
只有对整数来说，取模运算符才有意义
注意事项：
一旦运算中有不同类型数据，那么结果将会是数据类型范围大的那种
 

四则运算的'+'有常见的三种用法
1、对于整数那就是加法
2、对于字符char类型来说，在计算之前，char会被提升Int类型，然后在计算
3、char类型字符和Int类型数字，之间的对照表，ASCII和Unicode
4、对于字符串String(首字母大写：并不是关键字)来说，'+'代表字符连接字符操作
5、任何数据类型和字符串连接的时候都会变成字符串


自增 ++
自减 --
A
单独使用的话，++A,A++一样
混合使用的话,++A，先++后用；A++，先用后++
--和上面++一样
注意：只有变量才能使用自增，自减运算符，常量不可以发生改变，所以不能使用


复合运算符
注意事项
1、只有变量才能进行赋值运算操作
2、符合赋值运算隐藏了一个强制类型转换操作



方法运算符
大于 >
小于 <
等于 =
大于等于 >=
小于等于 <=
恒等 ==
不相等 !=



switch 注意事项
1、switch后面的小括号中只能是下列类型：
基本数据类型:byte,short,char,Int
引用数据类型:String,enum
2、switch语句可以很灵活，前后可以颠倒，而且break语句可以省略


开发工具
IDE
https://www.jetbrains.com/

项目
模块
包


mac-IDE快捷键
command + Shift + 上下,上下交换代码位置
option + command + L,代码格式化
command + delete, 删除光标所在行
command + /,单行注释
control + shift + /,多行注释



方法
定义方的完整的格式
修饰符 返回值类型 方法名称(参数类型:参数1，参数类型:参数2,...){
方法体
return 返回值;
}

修饰符：现阶段的固定写法 public static
方法名称：小驼峰命名规范
方法的参数：进入方法的参数类型
方法的返回值：
1、结束函数
2、将后面的返回值类型还给调用处



注意事项
1、方法定义的顺序无所谓
2、方法定义必须是紧挨着的，不能再一个方法的内部定义另一个方法
3、方法定义后续自己不会执行的，如果希望执行，一定要放的调用



方法重载

1、多个方法的名称一样，但是方法的参数不一样
好处：
1、只需记住一个方法名称就可以实现多个类似的功能
方法的重载于下列因素相关
1、参数个数不同
2、参数类型不同
3、参数的多类型的顺序不同

方法的重载于下列因素无关
1、与参数的名称无关
2、与方法的返回值类型无关


数组
1、数组是一种引用类型
2、数组中的数据，类型必须统一
3、数组的长度在程序运行期间不可改变
数组的初始化
在内存当中创建一个数组，并向其中赋予一些默认值
两种常见的初始化方法
1、动态初始化(指定长度)
动态初始化数组的格式
数据类型[] 数组名称 = new 数据类型[数组长度]
2、静态初始化(指定内容)
静态初始化
在创建数组的时候，不直接指定数据的个数，而是直接将具体的数据类型进行指定
静态初始化数组的格式
数据类型[] 数组名称 = new 数据类型[]{元素1，元素2,...}
省略格式
数据类型[] 数组名称 = {}
注意事项
1、静态初始化没有直接指定长度，但是仍然后自动推算等得到长度
2、静态初始化格式标准格式可以拆分为两个步骤
3、动态初始化也可以拆分两个步骤

使用建议
不确定数组中的具体内容，使用动态初始化，
否则已经确定了具体的内容，用静态初始化

直接打印数组名称得到的时数组内存地址的哈希值
使用动态初始化数组的时候，其中的元素将会自动拥有一个默认值，规则如下：
如果是整数类型，默认为0
如果是浮点数类,默认是0.0
如果是字符类型，默认为'\u0000'
如果是布尔类型，默认是false 
如果是引用类型，默认是null

Java的内存划分需要5个部分
1、栈(stack)，存放的都是方法的局部变量，
局部变量，方法的参数，或者方法的{}内部变量
作用域：一旦超出作用域，立即从栈内存中消失
2、堆(heap),凡是new出来的东西，都是在堆内存
堆内存中的都是一个地址值:16进制，堆内存里的数据都有默认值
规则为：
如果是整数，默认值为0，
如果是浮点数，默认是为0.0,
如果是字符默认为'\u0000',
如果是布尔值，默认为false,
如果是引用类型，默认是null
3、方法区(Method Area)，存储.class相关信息，包含方法的信息
4、本地方法栈(Navigation Method Stack),与操作系统有关
5、寄存器(pc Register)，与cpu先关，性能非常高



对象
注意事项
1、成员变量是定义在类中，在方法的内部
2、成员方法不要写static关键字

通常情况下，一个类并不能直接使用，需要根据类创建一个对象，才能使用
1、导包，也就是指出需要使用的类，在什么位置

我需要使用的Student类和我自己Demo02Student位于同一个包下，所以省略导包语句

import 包名称.类名称；
import com.lxl.day01.demo01.student
对于当前类属于同一个包的情况，可以省略导包语句不写
2、创建，格式
类名称 对象名 = new类名称()
Student stu = new Student()
3、使用,分两种情况
使用成员变量(对象名.成员变量名)
使用成员方法(对象名.成员方法名)
如果成员变量没有进行赋值，那么将会有一个默认值，规则和数组一样


 
局部变量和成员变量
1、定义的位置不一样
局部变量：定义在方法的内部
成员变量：在方法的外部，直接写在类当中
2、作用范围不一样
局部变量：只有方法当中才可以使用，出了方法就不能再用
成员变量：整个类全部都可以通用
3、默认值不一样
局部变量没有默认值，如果要想使用必须要手动赋值
成员变量，如果没有赋值，会有默认值，规则和数组一样
4、内存位置不一样
局部变量：位于栈内存
成员变量：位于堆内存
5、生命周期不一样
局部变量：随着方法进入栈而诞生，随着方法出栈而消失
成员变量：随着对象创建而诞生，随着对象被垃圾回收而消失

对于Boolean值Getter方法一定写成isXxx形式，而setXxx不变


构造方法
1、构造方法的名称必须和所在的类的名称完全一样，就连大小写也完全一样
2、构造方法不要写返回值类型，连void也不写
3、构造方法不能return 一个具体的返回值
4、如果没有编写任何构造方法那么编译器将会赠送一个构造方法，没有参数，方法体什么都不做 
public Student(){}
5、一旦编写了至少一个构造方法，那么编译器将不再赠送
6、构造方法也是可以重载的 
方法名称相同，参数列表不同 

Generater
1、批量产生set,Getter
2、类构造方法，快捷键

Scanner类功能
1、可以实现键盘输入数据，到程序中

引用类型的基本使用步骤
1、导包
import 包路径.类名称；
如果使用的目标类和当前类输入同一个包名下则可以省略导包语句不写
只有java.lang包下的内容不需要导包，其他的包都需要import 语句 
2、创建
类型名称 对象 = new 类名称()
3、使用
对象名.成员方法名()

创建对象的标准格式
类名称 对象名 = new 类名称();

匿名对象，只有右边的对象，没有左边的的名字和赋值运算符
new 类名称();


Random
// 范围实际上是0-9,[0,9]
int num = rd.nextInt(10);[0-9]
// 范围实际上是1-10,[1,10];
Int num1 = rd.nextInt(10) + 1; 
System.out.println(num);

 

ArrayList与数组的区别
1、数组的长度不能发生改变
2、ArrayList集合的长度是可以随意随意变化的
3、对于ArrayList来说，有一个尖括号<E>代表泛型
4、泛型也就是装在集合里的所有的元素，全都统一的什么类型
5、泛型只能是引用类型，不能是基本类型。
eg:
 创建一个ArrayList集合，集合的名称是list，里面装的全都是String字符串类型的数据
 备注：JDK 1.7+ 右侧的尖括号可以不写内容但是<>本身还是要写的
	ArrayList<String> list = new ArrayList<>(); 
常用方法
1、boolean add(E e),向集合中添加元素，参数的类型和泛型一致，返回值代表添加是否成功
2、E get(int Index),从集合中获取元素,参数是索引编号，返回值就是对应位置的元素
3、E remove(int Index),从集合中删除元素，参数是索引值,返回值就是对应位置的元素
4、int size():获取集合的尺寸长度，返回值是集合中包含元素的个数

注意事项
1、对于ArrayList集合来说，直接打印得到的不是地址值，而是内容
2、如果内容为空，得到的时空的中括号[]
3、使用基本类型包装类才能存到ArrayList里
基本类型 		包装类(java.lang下)
 byte			Byte
 short			Short
 int 			Integer
 long			Long
 float 			Float
 double 		Dobule
 char			Character
 boolean 		Boolean


字符串的特点
1、字符串的内容永远不变
2、正是因为字符串的内容不可改变，所以字符串内容可以共享使用
3、字符串效果上相当于是char[]字符数组，但是底层原理是byte[]字节数组

创建字符串的创建的3中方法
1、public String();创建一个空白字符串不含有任何内容
2、public String(char[] array);根据字符数组来创建对应的字符串
3、public String(byte[] array);根据字节数组来创建对应的字符串
直接创建
String str = "HelloWorld";
注意：直接写上双引号就是字符串对象，

字符串常量池：以双引号开头的字符串，就在字符串常量池中
对于基本类型来说是： == 进行数值比较
对于引用类型来说是： == 进行【地址值】比较

String str1 = "abc";
String str2 = "abc";
char[] charArr = {'a','b','c'};
String str3 = new String(charArr);
System.out.println(str1 == str2); // true
System.out.println(str1 == str3); // false
System.out.println(str2 == str3); // false

String 获取相关的常用的方法
public Int length(),获取字符串的长度
public String concat(String str) 拼接后返回一个新的字符串
public charAt(Int index) 获取索引位置的单个字符
public int indexof(String str) 查找字符串的索引位置，没有返回-1


public String subString(int index)
public String subString(int begin,int end),截取bgegin-end之间字符串[,)


Static，如果一个成员变量使用了static关键字，那么变量不在属于对象自己，而是属于所在的类，多个对象共享
1、如果有了static关键字，不需要创建对象，直接通过类名称来调用，
2、无论是成员变量还是成员方法，如果有了static都推荐使用类名称来调用
3、静态变量：类名称.类变量
4、静态方法:类名称.类方法 
注意：
1、静态不能直接访问非静态，在内存当中是现有的静态内容，后有的非静态内容
2、静态方法中不能用this，this代表对象


静态代码块格式

public class 类名称 {
// 特点：
// 当第一次用到本类时，静态代码块执行唯一的一次

static {
// 静态代码块的内容
System.out.println("静态代码块执行！")
}

}


java.until.Arrays 是一个与数组相关的工具类，里面提供了大量的静态方法
用来实现数组常见的操作
1、public static String toString(数组):将参数数组变成字符串(按照默认格式:[元素1，元素2，元素3...])
2、public static void Sort(数组)  按照默认升序 对数组的元素进行排序
备注：
如果是数值，sort是按照升序从小到大
如果是字符串，sort是按照字母升序
如果是自定义类型，那么这个自定义类需要有comparable或者comparable接口的支持


java.until.Math，是数学相关的工具类，里面提供了大量的工具方法，完成与数学相关的操作
pubic static double abs(double num)：获取绝对值
pubic static double ceil(double num)：向上取整
public static double floor(double num)：向下取整 
public static long round(double num)：四舍五入

继承关系中，父子类构建方法的特点
1、子类构建方法当中有一个默认隐藏的"super()"调用，所以一定是先调用的父类构造然后执行子类构造
2、可以通过super关键字让子类构造调用父类构造
3、super的父类构造调用，必须是子类构造方法的第一句，不能一个子类构造调用多次super构造
总结：子类必须调用父类构造方法，不写则赠送一个super(),写了则用了指定的super调用，
super只能有一个，还必须是第一个



super关键字的三种用法
1、在子类的成员方法中，访问父类的成员变量
2、在子类的成员方法中,访问父类的成员方法
3、在子类的构造方法中，访问父类的构造方法



super关键字用来访问父类的内容，而this关键字用来访问本类内容。
this三种用法
1、在本类的成员方法中，访问本类的成员变量
2、在本类的成员方法中，访问本类的成员方法
3、在本类的构造方法中，访问本类的而另一个构造方法
在第三种方法中要注意
A:this(...)调用也必须是构造方法的第一句，唯一一个
B:super和this两种调用不能同时使用



Java语言的单继承

1、一个类的直接父类只能有唯一的一个 class A{} class B extends A{}正确的
2、一个父类有很多子类


抽象就是加上abstract关键字,然后去掉大括号，直接分号结束
抽象类，抽象方法的所在类必须是必须是抽象类才行，在class之前写上abstract即可
eg:
public abstract class Animal {
// 抽象方法代表吃东西
public abstract void eat();
// 普通的成员方法
public void method() {}
}
如何使用抽象类和抽象方法
1、不能直接创建抽象类对象
2、必须用一个子类继承抽象父类
3、子类必须覆盖重写抽象父类当中的所有抽象方法
子类去掉抽象方法的abstract关键字，然后不上方法体和大括号
4、创建子类对象进行使用

注意：
1、一个抽象类中不一定有抽象方法，只要保证抽象方法所在的类是抽象类即可
2、没有抽象方法的抽象类也不能直接创建，在某些特殊的场景下有用途
3、抽象类的子类必须重写父类的所有的抽象方法，否则就会报错，除非抽象类的子类也是抽象类


接口就是多个类的公共部分
接口是一种引用的数据类型，最重要的内容就是其中的：抽象方法
如何定义一个接口格式
public interface 接口名称 {}
换成关键字interface之后，编译成的字节码文件任然是：.java->.class
如果是java7,那么接口中可以包含的内容有
1、常量
2、抽象方法
如果是java8可以增加额外的
3、默认的方法
4、静态方法
如果是java9还可以增加
5、私有方法


java8开始，接口允许定义默认方法
格式：
public defalut 返回值类型 方法名称 (参数列表) {
方法体...
}
备注
接口当中的方法可以j接口升级的问题
1、接口的默认方法，可以通过接口实现类对象，直接调用
2、接口的默认方法，也可以被接口实现类进行覆盖重写

问题描述
我们需要提取一个公有方法，用来解决两个默认方法之间的重复代码的问题
但是这个共有方法不应该被实现类使用，应该是私有化的
解决方法
从java9开始，接口当中允许定义私有方法
1、普通私有方法，解决多个默认方法之间重复代码部分
格式：
private 返回值类型 方法名称(参数列表){方法体}
2、静态私有方法，解决多个静态方法之间的重复代码部分
private static 返回值类型 方法名称(参数列表){方法体}


在Java 9+版本中，接口的内容可以有
1、成员变量其实常量，格式：
 [public] [static] [final] 数据类型 常量名称 = 值；
注意：
常量必须赋值，赋值后不能改变
常量名称完全大写有下划线进行分割 
2、接口最重要的就是抽象方法，格式：
[public] [abstract] 返回值类型 方法名称 (参数列表)；
注意：实现类必须覆盖重写接口所有的所有的抽象方法，除非实现类是抽象类
 
3、从java 8开始，接口里允许定义默认方法格式：
[public] default 返回值类型 方法名称(参数列表){方法体}
注意：默认方法也可以被覆盖重写

4、从java 8开始接口里允许静态方法，格式:
[public] static 返回值类型 方法名称 (参数列表){方法体}
注意：应该通过接口名称进行调用，不能通过实现类对象进行调用接口静态方法 

5、从java 9开始接口里允许定义私有方法，格式
普通私有方法，private 返回值类型 方法名称 (参数列表){方法体}
静态私有方法 private static 返回值类型 方法名称 (参数列表){方法体}
注意：private 方法只有接口自己调用，不能被实现类或者别人使用 



使用接口的时候需要注意
1、接口里是没有静态代码块或者静态方法的
2、一个类的直接父类是唯一的，但是一个类可以同时实现多个接口
格式：
public class MyInterfaceImpl implments MyInterfaceA,MyInterfaceB {
覆盖重写所有的抽象方法
3、如果实现类所实现的多个接口当中，存在重发的抽象方法，那么只需要覆盖重写一次即可。
}
4、如果实现类没有覆盖重写所有的接口当中的所有抽象方法，那么实现类就必须是一个抽象类
5、如果实现类所实现的多个接口当中，存在重复默认方法，那么实现类一定要对冲突的默认方法进行覆盖重写
6、一个类如果直接父类当中方法，和接口当中的默认方法，产生了冲突，优先用父类当中的方法


类与类之间是单继承，直接父类只有一个。
类与类之间是多实现的，一个类可以实现多个接口
接口与接口之间是多继承的

代码当中提现多特性，其实就是一句话，父类引用指向子类对象
格式：
父类名称 对象名 = new 子类名称();
或者
接口名称 对象名称 = new 实现类名称()

在多特的代码当中，成员方法的访问规则是：
看new的时谁，就优先用谁，没有则向上找
口诀：编译看左边，运行看右边。
对比一下：
成员变量，编译看左边，运行还看左边，
成员方法，编译看左边，运行看右边

如何才能知道一个父类引用对象，本来是什么子类？
格式：
对象 instanceof 类名称
这将会得到一个boolean值结果，也就是判断前面的对象，能不能当做后面类型的实例

Animal animal = new Animal();
if(animal instanceof Dog){
Dog dog = (Dog) animal;
}
if(animal instanceof Cat) {
Cat cat = (Cat) animal;
}

final关键字代表最终，不可变变
常见的4中用法
1、可以用来修饰一个类
2、也可以用来修饰一个方法
3、还可以用来修饰一个局部变量
4、还可以用来修饰一个成员变量

当final关键字用来修饰一个类的时候格式：
public final class 类名称{
// ...
}

含义：当前这个类不能有任何的子类
注意：
一个类如果是final的，那么其中的所有的成员变量都不能覆盖重写，不能使用一个final类作为父类

当final 关键字用来修饰一个方法的时候，这个方法就是最终方法，也就是不能被覆盖重写，
修饰符 final 返回值类型 方法名称(参数列表){
 方法体
}
注意事项
对于类，方法来说，abstract关键字和final关键字不能同时使用，因为矛盾


对于成员变量来说，如果使用final关键字修饰，那么这个变量也照样是不可变
1、由于成员变量具有默认值，所以用了final之后，必须手动赋值，不会再给默认值了
2、对于final的成员变量，要么使用直接赋值，要么使用通过构造方法赋值，二者选其一
3、必须保证类中所有的重载的类方法，最终会对final成员变量进行赋值。


java 的四种修饰符
                    public > protected > (default) > private
同一个类(我自己)     YES        YES         YES         YES
同一个包(我邻居)    YES        YES         YES         NO
不同包子类(我儿子)  YES        YES          NO         NO
不同包非子类(陌生人) YES         NO          NO         NO
注意事项(default)并不是关键字"default"，而是根本不写


如果一个事物内部包含另一个事物，那么这就是一个类内部包含另一个类
例如：身体和心脏的关系，又如：洗车和发动接的关系
分类
1、成员内部类
2、局部内部类(包含匿名内部类 )
成员内部类的定义格式：
修饰符 class 类名称 {
    修饰符 class 类名称 {
        // ...
    }
    // ...
}

内用外，可以随意访问，外用内，需要内部类对象。
========================================
如何使用成员内部类
1、间接方式：在外部类的方法当中，使用内部类，然后main只是调用外部类的方法
2、直接方式，公式：
类名称 对象名 = new 类名称()

外部类名称.内部类名称 对象名 = new 外部类名称().new  内部类名称();


局部内部类，如果希望访问所在方法的局部变量，那么这个局部变量必须是有效final的
从Java 8开始，只要局部变量事实不变，那么final的关键字可以省略

原因：
1、new来的对象在堆内存当中
2、局部变量是跟着方法走的，在栈内存当中
3、方法运行结束之后，立即出栈，局部变量就会立即消失。
4、但是new出来的对象会在堆中持续存在，直到垃圾回收为止。

// 如果出现了重名现象，那么格式是：外部类名称.this.外部类成员变量名

/*
如果一个类是定义在一个方法的，那么这就是一个局部内部类
`局部`，只有当前所属的方法才能使用它，出了这个方法外部就不能用了
定义格式：
修饰符 class 外部类名称 {
    修饰符 返回值类型 外部类方法名称(参数列表) {
        class 局部内部类名称  {
        // ...
        }
    }
}

小结一下类的权限修饰符
public > protected > (default) > private
定义一个类的时候，权限修饰符规则
1、外部类: public \（default）
2、成员内部类: public \ protected \ (default) \ private
3、局部内部类：什么都不能写


接口的实现类，（或者父类的子类），只需要使用唯一的一次，
那么这种情况下，就可以省略掉该类的定义，而改为使用【匿名内部类】
匿名内部类定义格式：
接口名称 对象名 = new 接口名称(){
// 覆盖重写所有抽象方法
}；

对格式"new 接口名称(){...}" 进行解析
1、创建对象的动作
2、接口就是匿名内部类实现哪个接口
3、这才是匿名内部类的内容

另外还需要注意几点内容
 1、匿名内部类在创建对象的时候只能使用唯一一次。
 如果希望多次创建对象，而且类的内容一样的话，那么就必须使用单独定义的实现类了
 2、匿名对象，在【调用方法】的时候，只能调用唯一一次。如果希望同一个对象，调用多次方法，那么
 必须给对象起一个名字
 3、匿名内部类是省略了【实现类\子类名称】，匿名对象是省略了对象【对象名称】。
 强调：
 匿名内部类和匿名对象不是一回事



java.lang.object类
类 object 是层次结构的根(最顶层)类，每一个类都是用object作为超类(父类)，
所有的对象都实现了这个类的方法


Person类继承了Object类所以可以使用Object的Equals方法
boolean equals(Object object) 其他对象是否与此对象相等
public boolean equals(Object obj) {
return (this == obj);
}

java.lang.object类
类 object 是层次结构的根(最顶层)类，每一个类都是用object作为超类(父类)，
所有的对象都实现了这个类的方法
看一个类是否重写了toString方法，直接打印这个类对应对象的名字即可
如果没有重写toString方法，打印的就是对象的地址值
如果重写了toString方法，就按照重写的方式打印


Object类的介绍：
object类是所有类的根类，一个类都会直接或者间接的继承该类。
1、toString方法
作用
1、打印对象的信息
2、重写前，打印的时类地址
3、重写后，打印的是对象当中的属性值
2、equals方法
作用
1、比较两个对象
2、重写前，比较是两个地址值
3、重写后，比较的是属性的值

Object equals方法
比较两个对象的方法是否相等



Collection

1、List,有索引，有序
ArrayList,底层数组实现，查询快，增删慢
LinkedList,底层链表实现，查询慢，增删快
Vector,

2、Set，无索引，不可以存储重复元素，存取无序
HashSet,底层是哈希表，和红黑树实现，
LinkedHashSet,底层是哈希表，链表实现，可以保证元素的存储顺序
TreeSet,底层是二叉树实现，一般用于排序 




泛型
泛型：是一种未知的数据类型，当我们不知道使用什么数据类型的时候，可以使用泛型，泛型也可以看出是一个变量
用来接收数据类型
E e:Element元素
T t:Type 类型
ArrayList集合在定义的时候 不知道集合中会存储什么类型的数据，所以类型使用泛型
E：未知的数据类型
public class ArrayList<E> {
public boolean add(E e){}
public E get(int index){}
}

创建集合对象的时候，就会确定泛型的数据类型
ArrayList<String> list = new ArrayList<>();

// 会把数据类型作为参数传递，把String赋值给泛型E
public class ArrayList<String> {
public boolean add(String e){}
public String get(int index){}
}

ArrayList<Student> stu = new ArrayList<Student>();
// 会把数据类型作为参数传递，把Student赋值给泛型E
public class ArrayList<Student> {
public boolean add(Student e){}
public Student get(int index){}
}


数据结构
1、栈，先进后出。弹夹
2、队列，先进先出。安检

数组，
1、查询快，数组的地址是连续的，可以通过数组的首地址找到数组，通过索引可以找到某一个元素。
2、增删慢，数组的长度是固定的  增加或者删除一个元素，必须创建一个新数组，把原数组的数据复制过来。

链表
1、查询慢，链表中地址不是连续的，每次查询元素必须从头开始查询
2、增删慢，建表增加或者删除一个元素，对链表的整体结构没有影响，所以增删快

链表中的每一个元素也称之为一个节点
一个节点，包含了一个数据源(存储数组)，两个指针域(存储地址)

单向链表：链表中只有一条链子，不能保证元素的顺序(存储元素和取出元素的顺序有可能不一致)
双向链表：链表中有两条链子，有一条链子是专门记录元素的顺序，是一个有序的集合，


二叉树：
分支不能超过两个，

排序树\查找树
在二叉树的基础上，元素是有大小顺序的。
左子树小，右子数大。

平衡树
左孩子和右孩子相等

补平衡树
左孩子!=右孩子

红黑树
特点趋近于平衡树，查询的速度非常的快，查询叶子节点最大次和最小次树，不能超过两倍。
约束：
1、节点可以是红色的或黑色的
2、跟节点是黑色的
3、叶子节点(空节点)是黑色的
4、每个红色的节点的子节点都是黑色的
5、任何一个节点到到其每一个叶子节点的所有路径上黑色节点数相同。


java.util.List接口 extends Collection接口

List接口的特点
1、有序集合，存储元素和取出元素的顺序是一致的(存储123,取出123)
2、有索引，包含了一些带索引的方法
3、允许存储重复的元素

List接口带索引的方法(),



HashCode集合，存储数据结构(哈希表)
jdk1.8版本之前 哈希表=数组+链表
jdk1.8版本之后 
哈希表 = 数组+链表
哈希表 = 数组+红黑树(提高查询的速度)

哈希表的特点：查询速度快。
存储数据到集合中先计算元素的哈希值
两个哈希值相同，但是元素不同，哈希冲突。
数组结构，把元素进行分组，相同哈希值元素为一组，链表红黑树结构把相同哈希值的元素连接到一起。
如果链表的长度超过8位，那么就会把链表转换为红黑树（提高差速度）


Set集合在调用add方法的时候，add方法会调用元素的hashCode方法和equals方法，判断元素是否重复。

Set集合存储元素不重复的元素
前提：存储的元素必须重写hashCode方法和equals方法,


java.util.Map<k,v>集合
Map集合的特点：
1、Map集合是一个双列集合，一个元素包含两个值（一个key，一个value）
2、Map集合中的元素，key和value的数据类型可以相同，也可以不同
3、Map集合中的元素，key是不允许重复的，value是可以重复的
4、Map集合中的元素，key和value是一一对应的

java.util.HashMap<k,v>集合 implements Map<k,v>接口
HashMap集合的特点：
1、HasMap的底层是哈希表，查询的速度特别快
JDK1.8之前，数组+单项链表
JDK1.8之后，数组+单项链表/红黑树(链表的长度超过8)：提高的查询速度
2、HasMap集合是一个无序的集合，存储元素和取出元素的顺序有可能不一致

java.util.LinkedHasMap<k,v>集合 extends HashMap<k,v>集合
linkedHasMap 的特点
1、linkedHasMap 的底层是哈希表+ 链表 保证迭代的顺序
2、linkedHasMap 是一个有序的集合 存储和取出元素的顺序一致

Map.Entry<K,V>:在map接口中有一个内部接口 entry
作用：当map集合一创建，那么就会在map集合中创建一个Entry对象，用来记录键与值(键值对对象，键与值得映射关系)->结婚证


HasMap存储自定义类型键值
Map集合保证key是唯一的:
1、作为key的元素，必须重写hashCode方法和equals方法，以保证key的唯一


HashTable，底层是一个哈希表，线程安全，单线程的集合，速度慢。
HashMap,底层是一个哈希表，线程不安全，多线程的集合，速度快。
HashMap集合，（之前所有的集合），可以存储null值，null键
HashTable集合，不能存储null值，null键

Hashtable和vecoor集合一样，在jdk1.2版本之后被更先进的集合(HashMap,ArrayList)取代了。
Hashtable的子类，properties依然活跃在历史的舞台，
properties集合是唯一一个和IO流相结合的集合

JDK9的新特性
List接口，set接口，map接口，里边增加了一个静态的方法of，可以一次性给集合添加多个元素。
static<E> List<E> of(E ....Element)
使用前提：
当集合中使用的元素个数已经确定，不在改变时使用
1、of方法只适用list，map，set接口，适用于接接口的实现类
2、of方法的返回值是一个不能改变的集合，集合不能使用add,put方法添加元素，会抛出异常
3、set接口和map接口在调用of方法时，不能有重复元素，否则，会抛出异常


Debug调试程序
1、可以让代码逐行执行，查看代码执行的过程，调试程序中出现的bug
2、使用方法，在行号的右边鼠标左键添加断点(每个方法的第一行，哪里有bug添加到哪里)
3、右键选择debug执行程序
4、程序就会停留在添加的一个断点处
5、执行程序
下箭头，逐行执行程序，f8
右下箭头，进入到方法中，f7
右上箭头，跳出方法,shift+f8
右箭头，跳到下一个断点,f9
红色方块，退出debug模式，
Console,切换控制台 


java.lang.throwable:类是java语言中所有错误或异类的超类
Exception:编译器异常，进行编译(写代码)java程序出现的问题
RunTimeException运行期异常，java程序运行过程中出现的问题
异常就相当于程序得了一个小毛病(感冒，发烧)，把异常处理掉，程序可以继续执行
Error:错误
错误就相当于程序得了一个无法治愈的毛病，必须修改源代码，程序才能继续执行，





并行：几个cpu同时去执行任务
并发：单个cpu在任务之间快速切换

进程，进入到内存的程序叫做进程，每个进程都有一个独立的内存空间，一个应用程序可以运行多个进程。
任务管理器->结束进程，那么就把进程从内存中清楚了
 

CPU：中央处理器，对数据进行计算，指挥电脑中软件和硬件干活
CPU的分类：
AMD
Inter inter Core I7 8866 4核心8线程
8个线程可以同时执行多个任务


主线程，执行主方法的线程
单线程程序：java线程中只有一个线程，执行从main方法开始，从上到下依次执行。


线程池
当程序第一次启动的时候，创建多个线程，保存到一个集合中，当我们想要使用线程的时候，就可以在集合中取出来
使用
Thread t = list.remove(0);返回的是被移除的元素(线程只能被一个任务使用)
Thread t = linked.removeFirst();
当我们使用完毕线程，需要把线程归还给线程池
list.add(t)
linked.addLast(t)

jdk1.5之后，jdk内置了线程池，我们可以直接使用
线程池的使用步骤

IO，概念和分类
i:input，输入(读取)
o:output,输出(写入)
流:(字符，字节)，1个字符=2个字节，1个字节=8个二进制位
输入：把硬盘中的数据，读取到内存中使用
输出：把内存中的数据，写入到硬盘中保存

字节流：InputStream(字节输入流)、outStream(字节输出流)
字符流：Reader(字符输入流)、Write(字符输出流)



应用层：http,FTP
传输层 UDP,TCP
网络层
物理层


UDP:用户数据报协议(User DataGram Protocol),UDP是无连接通信协议，即在数据传输时，数据的发送端和接收端不建立逻辑连接，由于使用UDP协议消耗资源小，通信效率高
特点：数据被限制在64kb内，超出这个范围就不能发送

TCP:传输控制协议(Transmission Control Protocol)TCP是面向连接的通信协议，即传输数据之前，在发送端和连接段建立逻辑连接，然后在传输数据，它提供了两台计算机之间可靠无差错的数据传输
在TCP连接中必须要明确客户端和服务端，由于客户端向服务端发出连接请求，每次连接的创建都需要经过三次握手
三次握手：TCP协议中，在发送数据的准备阶段，客户端和服务器之间的三次交互，以保证连接的可靠。
第一次握手：客户端向服务器端发出连接请求，等待服务器确认
第二次握手：服务器端向客户端回送一个请求，通知客户端，收到了连接请求
第三次握手：客户端再次向服务端发送确认信息，确认连接。整个交互过程如下图所示

完成三次握手，连接建立后，客户端和服务端就可以开始进行数据传输了，由于这种面向连接的特性，TCP协议可以保证传输数据的安全，所以应用十分广泛，例如下载文件，浏览网页等。




ip:电脑的唯一标识
ipconfig
ping

本机ip地址
127.0.0.1
localhost

计算机通过网络可以连接到一起，那么计算机就可以通信了(发送数据...)我们通过ip地址可以找到对方的计算机
端口号：是一个逻辑端口，我们无法直接看到，可以使用一些软件查看端口号
当我们使用网络软件一打开，那么操作系统就会为网络软件分配一个算计的端口号
或者网络软件在打开的时候和系统要指定的端口号
端口号是由两个字节组成，取值范围在0-65535之间
注意：
1024之前的端口号我们不能使用，已经被系统分配给已知的网络软件
网络软件的端口号不重复
常用的端口号
1、80端口，网络端口。www.baidu.com.80 正确网址 www.baidu.com.80 错误网址打不开
2、数据库 mysql:3306, oracle：1521
3、tomcat服务器:8080


服务器端必须明确的两件事情
1、多个客户端同时和服务器进行交互，服务器必须明确和那个客户端进行的交互，在服务器端有一个方法叫做accept获取到请求的客户端对象
2、多个客户端同时和服务器端交互，就要使用多个IO流对象
服务器是没有IO流的，服务器可以获取到请求的客户端的对象socket
使用每个客户端socket中提供的IO流对象和客户端进行交互
服务端使用客户端的字节输入流读取客户端发送的数据
服务器使用客户端的字节输出流给客户端回写数据

简单记：服务器使用客户端的流和客户端进行交互

##Junit单元测试
*测试分类：
	1、黑河测试：不需要写代码，给输入值，看程序是否能够输出期望值
	2、白盒测试：需要写代码，关注程序的具体的执行流程
*Junit使用：白盒测试
	*步骤:
	1、定义一个单元测试类(测试用例)
	   *建议：
		*测试类名：被测试的类名后面加一个Test
	   	*包名：xxx.xxx.xx.test	cn.itcast.test
	2、定义测试方法：可以独立运行
	   *建议：
		*方法名:test测试的方法名 testAdd()
		*返回值:void
		*参数列表:空参
	3、给方法加@Test
	4、导入Junit依赖环境

	*判定结果：
	   *绿色：成功
   	   *红色：失败
	   *一般我们会使用断言操作来处理结果
		*Assert.assertEquals(期望的结果,运算的结果)
	*补充：
	 * @Before:
		* 修饰的方法会在测试方法之前被自动执行
	 * @After:
		* 修饰的方法会在测试方法之后被自动被执行
	 
## 反射：框架设计的灵魂
    *框架：半成品软件。可以在框架的基础上进行软件的开发，简化编码
    *反射：将类的各个组成部分封装为其他的对象，这就是反射机制
	*好处：
	   1、可以在程序运行过程中，操作这些对象
	   2、解耦，提高程序的可扩展性。
    *获取class对象的方式
	1、Class.forName("全类名")：将字节码文件加载进内存，返回class对象
		*多用于配置文件，将类名定义在配置文件中。读取文件，加载类
	2、类名.class:通过类名的属性class获取
		*多用于参数的传递
	3、对象.getClass():getClass方法在Object类中定义着
		*多用对象的获取字节码的方式
	*结论：
	同一个字节码文件(*.class)在一次程序运行过程中，只会被加载一次，不论通过哪一种的方式获取的class对象
	都是同一个。


     *Class对象功能：
	*获取功能
	1、获取成员变量们
	* Field[] getFields()
	* Field getField(String name)
	* Field getDeClaredFields()
	* Field getDeclaredField(String name)
	2、获取构造方法们
	* Constructor<?>[] getConstructors()
	* Constructor<T> getConstructor(类<?>...parameterTypes)
	* Constructor<T> getDeclaredConstructor(类<?>...parameterTypes)
	* Constructor<?> [] getDeclaredConstructors()
	3、获取成员方法们
	* Method[] getMethods()
	* Method getMethod(String name,类<?>...parameterTypes)
	* Method[] getDeclaredMethods()
	* Method getDeclaredMethod(String name,类<?>...parameterTypes)
	4、获取类名


案例：利用反射写一个框架
前提：写一个`框架`，不能改变类的任何代码的前提下。可以帮我们创建任意类的对象，并且执行其中任意方法
            *实现：
                1、配置文件
                2、反射
            *步骤：
                1、将需要创建的对象名和需要执行的方法定义在配置文件中
                2、在程序中加载读取配置文件
                3、使用反射技术来加载类文件进内存
                4、创建对象
                5、执行方法

##注解
	*概念：说明程序的。给计算机看的
	*注释：用文字描述程序的。给程序员看到

	*定义：注解(Annotation),也叫元数据。一种代码级别的说明，它是JDK1.5及以后版本引入的一个特性
与类，接口，枚举是在同一个层次，他可以声明在包，类，字段，方法，局部变量，方法参数等的前面，用来对这些元素的进行说明，注释。
	
	*概念描述：
		*JDK1.5之后的新特性
		*说明程序的
		*使用注解:注解名称
	*作用分类：
		*编写文档，通过代码里标识的注解生成文档【生成doc文档】
		*代码分析，通过代码里标识注解生成代码分析【使用反射】
		*编译检查，通过代码里的注解让编译器能够实现基本的编译检查【Override】
	
	*JDK中预定义的一些注解
	@Override		:检查被该注解标注的方法是否是继承自父类(接口)的
	@depercated		:将该注解标注的内容，表示已过时
	@suppressWarning	:压制警告
		*一般传递参数all:@SuppressWarnings("all")
	
	*自定义注解
		*格式：
		 元注解
		 public @interface 注解名称{
		 属性列表	
		}
		*本质：注解本质上是一个接口，该接口默认继承Annotation
		  * public interface MyAnno extends java.lang.annotation.Annotation{}
		*属性:接口中可以定义抽象方法
		   *要求：
			1、属性的返回值类型有下列取值
				*基本数据类型
				*String
				*枚举
				*注解
				*以上类型的数组
			2、定义了属性，在使用时需要给属性赋值
				1、如果定义属性时，使用default关键字给默认初始化值，则使用注解时，可以不进行属性的赋值
				2、如果只要一个属性赋需要赋值，并且属性的名称是value,则value可以省略，直接定义值即可
				3、数组赋值时，值使用{}包裹，如果数组中只有一个值，则大括号可以省略
		*元注解：用于描述注解的注解
			* @Target：描述注解能够作用的位置
				*ElementType取值：
					* TYPE：可以作用于类上
					* METHOD:可以作用域方法上
					* FIELD:可以作用域成员变量上
			* @Retention:描述注解被保留的阶段
			   * @Retention(RetentionPolicy.RUNTIME):当前被描述的注解，会保留到class字节码文件中，
			      并被JVM读取到
			* @Documented:描述注解是否被抽取到api文档中
			* @inherited:描述注解是否被子类继承

	*在程序中使用(解析)注解:获取注解中定义的属性值
	  1、获取注解定义的位置对象(Class,Method,Field)
	  2、获取指定的注解
		*getAnnotation(Class)
	  3、调用注解中的抽象方法获取配置的属性值

	*小结
	1、以后大多时候，我们会使用注解，而不是自定义注解
	2、注解给谁用？
		1、编译器
		2、给解析程序用
	3、注解不是程序的一部分，可以理解为注解就是一个标签


	





